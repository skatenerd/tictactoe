#!/usr/bin/python
import re
import itertools
import random

class tic_tac_toe_board:
    #scores of various board positions
    score_dict={}
    
    
    def __init__(self,board=((0,0,0),(0,0,0),(0,0,0))):
        self.board=board

    def remaining_moves(self):
        """
        what squares haven't filled up yet?
        """
        return [(y,x) for (y,x) in itertools.product(range(3),range(3)) if self.board[y][x]==0]

    def fails_boundaries(self,(input_row,input_col)):
        rtnval=False
        legal_idx_range=set(range(0,3))
        coordinates_within_bounds=input_row in legal_idx_range and input_col in legal_idx_range
        return not coordinates_within_bounds
    
    def commit_move(self,(move_y,move_x),player):
        """
        Return a fresh board, which looks like the previous board after
        "player" has applied "(move_y,move_x)"
        this is kind of ugly.  i'm not sure how to avoid casting to a list of lists..
        """
        assert (move_y,move_x) in self.remaining_moves(), "committing move to occupied square"
        board_as_list=map(lambda row:list(row),self.board)
        board_as_list[move_y][move_x]=player
        new_board=tuple(map(lambda row:tuple(row),board_as_list))
        return tic_tac_toe_board(new_board)
    def grid_path_generator(self,y_step,x_step,starting_posn):
        """
        produces a generator which yields a sequence of positions on the board.
        this is useful for determining whether there is a winner on the board.
        if you want to check for a winner in the first row, you can "walk down" the first row
        making sure that every resident of that row is identical
        """
        cur_posn=starting_posn
        while not self.fails_boundaries(cur_posn):
            yield cur_posn
            cur_posn=(cur_posn[0]+y_step,cur_posn[1]+x_step)

    def winner_on_path(self,path):
        """
        walk along the provided path, seeing if a winning-triplet
        lives on this path.  we require that all three numbers are
        equal and nonzero.
        """
        (frst_y,frst_x)=path.next()
        frst_val=self.board[frst_y][frst_x]
        path_residents_identical=True
        for (cur_y,cur_x) in path:
            cur_val=self.board[cur_y][cur_x]
            if cur_val!=frst_val:
                path_residents_identical=False
        if path_residents_identical and frst_val != 0:
            return frst_val
        else:
            return 0
    
    def winner_on_board(self):
        """
        does the current board contain a winner (should this game end)?
        generate all of the possible win-paths, and walk down each one,
        checking for a winner
        """
        col_paths=[self.grid_path_generator(1,0,(0,x)) for x in range(3)]
        row_paths=[self.grid_path_generator(0,1,(y,0)) for y in range(3)]
        diagonal_paths=[self.grid_path_generator(1,1,(0,0)),self.grid_path_generator(-1,1,(2,0))]
        winner=0
        for p in col_paths+row_paths+diagonal_paths:
            p_winner=self.winner_on_path(p)
            if p_winner!=0:
                winner=p_winner
                break
        return winner
    def is_occupied_square(self,(input_row,input_col)):
        return (self.board[input_row][input_col]!=0)

    def score_move(self,(move,player)):
        """
        if "player" committed "move", what would the score of the
        resulting board be?
        """
        result_board=self.commit_move(move,player)
        return result_board.score_posn(other_player(player))

    def best_next_move(self,player):
        cur_posn_score=self.score_posn(player)
        for m in self.remaining_moves():
            if self.score_move((m,player))==cur_posn_score:
                return m

    
    def record_score(self,player,score):
        """
        this is just a wrapper to make the code read more like english
        and to handle assertion-checking
        """
        if (self.board,player) in self.score_dict:
            assert self.score_dict[(self.board,player)]==score
        else:
            self.score_dict[(self.board,player)]=score
    
    def score_posn(self,player):
        """
        What is the "score" of the current board?
        see above for an explanation of what "score" means
        Note that we are using a dictionary object to avoid extra work
        """
        cur_winner=self.winner_on_board()
        if cur_winner!=0:
            #first obvious check - is the game over?
            self.record_score(player,cur_winner)
            return cur_winner
        elif len(self.remaining_moves())==0:
            #nobody can move, and there is no winner.  stale mate.
            return 0
        elif len(self.remaining_moves()) >8:
            #you can't lose after two moves.....
            return 0
        elif (self.board,player) in self.score_dict:
            #we've already memorized this into the score dictionary!
            return self.score_dict[(self.board,player)]
        else:
            #all of the obvious checks have yielded no results.
            #so, find the next move yielding maximal (or minimal) score
            cur_remaining_moves=self.remaining_moves()
            num_remaining_moves=len(cur_remaining_moves)
            goal_fn=player_goal_fn(player)
    
            #suppose we are the score-minimizing player.
            #we want to figure out how small we can make
            #the score of the resulting move
            rtn_score=goal_fn(map(self.score_move,
                                zip(cur_remaining_moves,
                                    (player,)*num_remaining_moves)))
            self.record_score(player,rtn_score)
            return rtn_score
    def __str__(self):
        rtn_str="\n".join(["|"+"|".join([num_to_avatar(n) for n in row])+"|" for row in self.board])
        return rtn_str




    


def num_to_avatar(n):
    if n==-1:
        return "X"
    elif n==0:
        return "_"
    elif n==1:
        return "O"
    else:
        raise ValueError("The board contains numbers outside {-1,0,1}")

def parse_to_integer_pair(input_str):
    """
    Trying to be flexible.  Try to extract two natural numbers from
    the input.
    """
    num_regex=re.compile(r'[0-9]+')
    matches=num_regex.findall(input_str)
    if len(matches)==2:
        return tuple([int(m) for m in matches])
    else:
        return None

def prompt_valid_move(board):
    """
    extract meaningful input from user.  keep trying until something
    useful comes out
    """
    move=parse_to_integer_pair(raw_input("Please enter your move\n"))
    valid_move=False
    while not valid_move:
        if not move:
            move=parse_to_integer_pair(raw_input("I cannot parse your move into coordinates, try again\n"))
        elif board.fails_boundaries(move):
            move=parse_to_integer_pair(raw_input("Previous move was off the board, try again\n"))
        elif board.is_occupied_square(move):
            move=parse_to_integer_pair(raw_input("Prevoius move was in an occupied place, try again\n"))
        else:
            valid_move=True
    return move

def player_goal_fn(player):
    """
    As described above, one player wants to maximize the score
    on the grid, and the other player wants to minimize the score.
    so, player 1's "goal" corresponds to the function max
    """
    assert player in [-1,1]
    if player==1:
        return max
    else:
        return min

def other_player(player):
    #...
    return player * -1

def run_game():
    print "welcome.  you will enter your moves in ZERO-INDEXEXD ROW,COLUMN format."
    print "so, (0,0) is a valid move.  (2,0) means the lower left corner"
    print "this is NOT the same as the x,y coordinates of your childhood\n\n"
    #the "O" player always goes first.
    #depending on the random number roll, the player goes first as "O"
    #or second as "X"
    human_team=1 if random.random() > .5 else -1
    computer_team=other_player(human_team)
    print ("we have chosen randomly for you."+
          "you will move {0} and play as {1}.".format("first" if human_team==1 else "second",
                                                      "\""+str(num_to_avatar(human_team)+"\"")))
    cur_player=1
    cur_board=tic_tac_toe_board()
    while not cur_board.winner_on_board() and len(cur_board.remaining_moves())>0:
        if cur_player==human_team:
            move=prompt_valid_move(cur_board)
        else:
            move=cur_board.best_next_move(cur_player)
            print "computer has chosen {0}".format(move)
        cur_board=cur_board.commit_move(move,cur_player)
        print cur_board
        print "\n"
        cur_player=other_player(cur_player)                                                                                       

    if cur_board.winner_on_board()==computer_team:
        print "i win!"
    else:
        print "we tied.  you must be brilliant"
          



if __name__=="__main__":
    empty_board =(( 0, 0, 0),
                  ( 0, 0, 0),
                  ( 0, 0, 0))
                  
    test_board_0=(( 1, 0, 0),
                  ( 0, 1, 0),
                  ( 0, 0, 1))
    test_board_1=(( 1, 1, 1),
                  ( 0,-1, 0),
                  (-1, 0, 0))
    test_board_2=(( 0,-1, 0),
                  ( 0,-1, 0),
                  ( 0,-1, 0))

    test_board_3=(( 0, 1, 0),
                  ( 0, 0, 0),
                  ( 0,-1, 0))

    test_board_4=((-1,-1, 1),
                  ( 1, 0, 0),
                  (-1, 1, 0))
    test_board_5=((-1,-1, 1),
                  ( 1, 1, 0),
                  (-1,-1, 1))
    test_board_6=(( 0, 0, 0),
                  ( 0, 0, 0),
                  ( 0,-1, 0))

    board_4=tic_tac_toe_board(test_board_4)
    print board_4.score_posn(1)
    print board_4.score_posn(-1)

    board_5=tic_tac_toe_board(test_board_5)
    print board_5.score_posn(1)
    print board_5.score_posn(-1)
    board_6=tic_tac_toe_board(test_board_6)
    print board_6.score_posn(1)
    run_game()
